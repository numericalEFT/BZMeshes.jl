var documenterSearchIndex = {"docs":
[{"location":"api_reference/","page":"API Reference","title":"API Reference","text":"","category":"page"},{"location":"api_reference/","page":"API Reference","title":"API Reference","text":"Modules = [BrillouinZoneMeshes]","category":"page"},{"location":"lib/BZMeshes/#BZMeshes","page":"BZMeshes","title":"BZMeshes","text":"","category":"section"},{"location":"lib/BZMeshes/","page":"BZMeshes","title":"BZMeshes","text":"This module defines meshes with information of Brillouin zone stored.","category":"page"},{"location":"lib/BZMeshes/","page":"BZMeshes","title":"BZMeshes","text":"Modules = [BrillouinZoneMeshes.BZMeshes]","category":"page"},{"location":"lib/BZMeshes/#BrillouinZoneMeshes.BZMeshes.UniformBZMesh-Union{Tuple{}, Tuple{DIM}, Tuple{T}} where {T, DIM}","page":"BZMeshes","title":"BrillouinZoneMeshes.BZMeshes.UniformBZMesh","text":"function UniformBZMesh(; br::Cell, origin, size, shift)\n\ncustomized constructor for UniformBZMesh. The parameters origin and shift is provided to customize the mesh as Gamma-centered or M-P mesh. \n\nParameters:\n\ncell: Cell info\norigin: a number indicating shift of origin.    the actuall origin becomes origin*(b1+b2+b3)   default value origin=-1/2 takes (0,0,0) to center of 1st BZ, origin=0 makes mesh[1,1,1]=(0,0,0)+shift\nsize: size of the mesh\nshift: additional k-shift for mesh points.    actuall shift is shift*(b1/N1+b2/N2+b3/N3)   for even N, shift=1/2 avoids high symmetry points while preserve symmetry.\n\n\n\n\n\n","category":"method"},{"location":"lib/BZMeshes/#BrillouinZoneMeshes.MeshMaps.MeshMap-Union{Tuple{UniformBZMesh{T, DIM}}, Tuple{DIM}, Tuple{T}, Tuple{UniformBZMesh{T, DIM}, Bool}, Tuple{UniformBZMesh{T, DIM}, Bool, Any}} where {T, DIM}","page":"BZMeshes","title":"BrillouinZoneMeshes.MeshMaps.MeshMap","text":"function MeshMaps.MeshMap(mesh::UniformBZMesh{T,DIM}, is_time_reversal::Bool=true, tol_symmetry=PointSymmetry.SYMMETRY_TOLERANCE)\n\ncreate a MeshMap for the given UniformBZMesh based on the symmetry of the Brillouin zone.\n\n\n\n\n\n","category":"method"},{"location":"lib/BZMeshes/#BrillouinZoneMeshes.BZMeshes.DFTK_Monkhorst_Pack-Union{Tuple{}, Tuple{DIM}, Tuple{T}} where {T, DIM}","page":"BZMeshes","title":"BrillouinZoneMeshes.BZMeshes.DFTK_Monkhorst_Pack","text":"function DFTK_Monkhorst_Pack(; cell, size, shift, kshift)\n\ncustomized constructor for UniformBZMesh.  Reproduce the M-P mesh from DFTK convention.    \n\nParameters:\n\ncell: Cell info\nsize: size of the mesh\nshift: 3D Bool Vector indicating if k-points are shifted by 1/2 in cartesian coordinates in DFTK convention\n\n\n\n\n\n","category":"method"},{"location":"lib/BZMeshes/#BrillouinZoneMeshes.BZMeshes.Monkhorst_Pack-Union{Tuple{}, Tuple{DIM}, Tuple{T}} where {T, DIM}","page":"BZMeshes","title":"BrillouinZoneMeshes.BZMeshes.Monkhorst_Pack","text":"function Monkhorst_Pack(; cell, size, shift, kshift)\n\ncustomized constructor for UniformBZMesh.  Reproduce the M-P mesh from VASP convention.\n\nMonkhorst-Pack: origin=-1/2, consistent with VASP to be consistent with DFTK: \n\nN is even, VASP is the same as DFTK: shift=0 will include Gamma point, shift=1/2 will not\nN is odd, VASP is different as DFTK: shift=0 will not include Gamma point, shift=1/2 will\n\nParameters:\n\ncell: Cell info\nsize: size of the mesh\nshift: 3D Bool Vector indicating if k-points are shifted by 1/2 in cartesian coordinates in DFTK convention\n\n\n\n\n\n","category":"method"},{"location":"lib/AbstractMeshes/#AbstractMeshes","page":"AbstractMeshes","title":"AbstractMeshes","text":"","category":"section"},{"location":"lib/AbstractMeshes/","page":"AbstractMeshes","title":"AbstractMeshes","text":"This module provides the abstract type of meshes defined in this package.","category":"page"},{"location":"lib/AbstractMeshes/","page":"AbstractMeshes","title":"AbstractMeshes","text":"Modules = [BrillouinZoneMeshes.AbstractMeshes]","category":"page"},{"location":"lib/AbstractMeshes/#BrillouinZoneMeshes.AbstractMeshes","page":"AbstractMeshes","title":"BrillouinZoneMeshes.AbstractMeshes","text":"module AbstractMeshes\n\nThis sub-module defines abstract type \"AbstractMesh\",  from which all concrete types of meshes in this package derive.  All functions expected by a sub-type of \"AbstractMesh\" are defined in this file,  including AbstractArray interface requirements and functions like \"locate\" and \"volume\". If the implementation of a function is type-specific,  the function defined in this file will return error.\n\n\n\n\n\n","category":"module"},{"location":"lib/AbstractMeshes/#BrillouinZoneMeshes.AbstractMeshes.AbstractMesh","page":"AbstractMeshes","title":"BrillouinZoneMeshes.AbstractMeshes.AbstractMesh","text":"abstract type AbstractMesh{T,DIM} <: AbstractArray{SVector{T,DIM},DIM}\n\nParent type of all meshes in this package.\n\nThe default return value of AbstractMesh should be a SVector{T,DIM},  which is assumed to be the cartesian coordinates of the mesh points,  even if the mesh it self is polar.  Other representations of mesh points such as polar coordinates  and fractional coordinates could be provided via getindex with traits.\n\nRequired Fields:\n\nsize: the size of the mesh as a tuple of integers\n\n\n\n\n\n","category":"type"},{"location":"lib/AbstractMeshes/#Base.getindex-Tuple{AbstractMesh, Vararg{Any}}","page":"AbstractMeshes","title":"Base.getindex","text":"function Base.getindex(mesh::AbstractMesh, ...)\n\nReturn mesh point at given index of the mesh.  Index could be given as linear index or cartesian index. By default return cartesian coordinates of the point, other representations could be obtained by traits:\"mesh[FracCoords, i]\".\n\nParameters:\n\nmesh: mesh\nCoords: traits of coordinate type, omitted by default\ni/inds...: index of mesh point in linear or cartesian index\n\n\n\n\n\n","category":"method"},{"location":"lib/AbstractMeshes/#BrillouinZoneMeshes.AbstractMeshes.locate-Tuple{AbstractMesh, Any}","page":"AbstractMeshes","title":"BrillouinZoneMeshes.AbstractMeshes.locate","text":"function AbstractMeshes.locate(mesh, x)\n\nlocate mesh point in mesh that is nearest to x. Useful for Monte-Carlo algorithm. Could also be used for zeroth order interpolation.  Mesh specific implementation required.\n\nParameters\n\nmesh: aimed mesh\nx: cartesian pos to locate\n\n\n\n\n\n","category":"method"},{"location":"lib/AbstractMeshes/#BrillouinZoneMeshes.AbstractMeshes.volume-Tuple{AbstractMesh}","page":"AbstractMeshes","title":"BrillouinZoneMeshes.AbstractMeshes.volume","text":"function AbstractMeshes.volume(mesh, i)\n\nvolume represented by mesh point i. When i is omitted return volume of the whole mesh.  Mesh specific implementation required.\n\nParameters:\n\nmesh: mesh\ni: index of mesh point, if ommited return volume of whole mesh\n\n\n\n\n\n","category":"method"},{"location":"lib/Cells/#Cells","page":"Cells","title":"Cells","text":"","category":"section"},{"location":"lib/Cells/","page":"Cells","title":"Cells","text":"This module provides the Brillouin zone container.","category":"page"},{"location":"lib/Cells/","page":"Cells","title":"Cells","text":"Modules = [BrillouinZoneMeshes.Cells]","category":"page"},{"location":"lib/Cells/#BrillouinZoneMeshes.Cells.Cell","page":"Cells","title":"BrillouinZoneMeshes.Cells.Cell","text":"struct Cell{T, DIM}\n\nContainer storing information of Brillouin zone. Including lattice vector, reciprocal lattice vector and their inverse; volume of unit cell and reciprocal unit cell; G vectors for extended Brillouin zone.\n\nLattice parameters lattice are given by a 33 matrix with floating point values, where 𝐚, 𝐛, and 𝐜 are given as columns.\n\nParameters:\n\nT: type of data\nDIM: dimension of the Brillouin zone\n\nMembers:\n\nlattice: lattice vector\nrecip_lattice: reciprocal lattice vector\ninv_lattice: inverse of lattice vector\ninv_recip_lattice: inverse of reciprocal lattice vector\ncell_volume: volume of lattice unit cell\nrecip_cell_volume: volume of reciprocal lattice unit cell\natoms: list of integers representing atom types\npositions:  # positions[i] is the location of atoms[i] in fract. coords\natom_groups`:  atoms[i] == atoms[j] for all i, j in atom_group[α]\nG_vector: a list of G vectors in extended Brillouin zone\nsymmetry: symmetry of the Brillouin zone\n\n\n\n\n\n","category":"type"},{"location":"lib/Cells/#BrillouinZoneMeshes.Cells._compute_inverse_lattice-Union{Tuple{AbstractMatrix{T}}, Tuple{T}} where T","page":"Cells","title":"BrillouinZoneMeshes.Cells._compute_inverse_lattice","text":"Compute the inverse of the lattice. Require lattice to be square matrix\n\n\n\n\n\n","category":"method"},{"location":"lib/Cells/#BrillouinZoneMeshes.Cells._compute_recip_lattice-Union{Tuple{AbstractMatrix{T}}, Tuple{T}} where T","page":"Cells","title":"BrillouinZoneMeshes.Cells._compute_recip_lattice","text":"Compute the reciprocal lattice. We use the convention that the reciprocal lattice is the set of G vectors such that G ⋅ R ∈ 2π ℤ for all R in the lattice.\n\n\n\n\n\n","category":"method"},{"location":"lib/Cells/#BrillouinZoneMeshes.Cells.default_symmetries-Union{Tuple{BrillouinZoneMeshes.Cells.Cell{T, DIM}}, Tuple{DIM}, Tuple{T}} where {T, DIM}","page":"Cells","title":"BrillouinZoneMeshes.Cells.default_symmetries","text":"Default logic to determine the symmetry operations to be used in the model.\n\n\n\n\n\n","category":"method"},{"location":"lib/Cells/#BrillouinZoneMeshes.Cells.get_latvec-Union{Tuple{T}, Tuple{AbstractMatrix{T}, Int64}} where T","page":"Cells","title":"BrillouinZoneMeshes.Cells.get_latvec","text":"Return I-th lattice vector of lattice. Lattice vectors are specified column-wise in lattice::Matrix.\n\n\n\n\n\n","category":"method"},{"location":"lib/Cells/#BrillouinZoneMeshes.Cells.standard_cell-Tuple{}","page":"Cells","title":"BrillouinZoneMeshes.Cells.standard_cell","text":"function standard_cell(;\n    dtype=Float64,\n    lattice::AbstractMatrix,\n    atoms::AbstractVector=[1,],\n    positions::AbstractVector{<:AbstractVector}=[zeros(dtype, size(lattice, 1)),],\n    primitive=true,\n    correct_symmetry=true,\n    # magnetic_moments=[],\n    tol_symmetry=PointSymmetry.SYMMETRY_TOLERANCE,\n    G_vector=nothing)\n\nReturns a Cell object with crystallographic conventional cell according to the International Table of Crystallography Vol A (ITA) in case primitive=false. If primitive=true the primitive lattice is returned in the convention of the reference work of Cracknell, Davies, Miller, and Love (CDML). Of note this has minor differences to the primitive setting choice made in the ITA.\n\n\n\n\n\n","category":"method"},{"location":"","page":"Home","title":"Home","text":"CurrentModule = BrillouinZoneMeshes","category":"page"},{"location":"#BrillouinZoneMeshes","page":"Home","title":"BrillouinZoneMeshes","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Documentation for BrillouinZoneMeshes.","category":"page"},{"location":"","page":"Home","title":"Home","text":"This package provides general-purpose multi-dimensional meshes for numerical  representation of continuous functions and specialized meshes  for functions on Brillouin Zones. ","category":"page"},{"location":"#Getting-started","page":"Home","title":"Getting started","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Setup with:","category":"page"},{"location":"","page":"Home","title":"Home","text":"    DIM = 2;\n    # square lattice\n    lattice = Matrix([1.0 0; 0 1]');\n    # create Brillouin zone\n    br = BZMeshes.Cell(lattice=lattice);\n    # uniform mesh\n    umesh = BZMeshes.UniformBZMesh(cell=br, size=(4, 4));\n    # symmetry reduce map\n    mm = MeshMaps.MeshMap(umesh);\n    # reduced mesh\n    rmesh = ReducedBZMesh(umesh, mm);","category":"page"},{"location":"","page":"Home","title":"Home","text":"and here are some examples of usage:","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> using BrillouinZoneMeshes; DIM = 2; lattice = Matrix([1.0 0; 0 1]'); br = BZMeshes.Cell(lattice=lattice); umesh = BZMeshes.UniformBZMesh(cell=br, size=(4, 4)); mm = MeshMaps.MeshMap(umesh); rmesh = ReducedBZMesh(umesh, mm);\n\njulia> length(umesh), length(rmesh)\n(16, 3)\n\njulia> AbstractMeshes.locate(rmesh, [1,1])\n3\n\njulia> rmesh[3]\n2-element StaticArraysCore.SVector{2, Float64} with indices SOneTo(2):\n 0.7853981633974483\n 0.7853981633974483\n\njulia> AbstractMeshes.volume(rmesh) / 4π^2\n1.0\n\njulia> data = ones(3)\n3-element Vector{Float64}:\n 1.0\n 1.0\n 1.0\n\njulia> AbstractMeshes.integrate(data, rmesh)\n39.47841760435743\n\njulia> AbstractMeshes.interp(data, rmesh, [0.3,-0.2])\n1.0","category":"page"},{"location":"#General","page":"Home","title":"General","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Various mesh grids for different purposes are defined as concrete types  derived from AbstractMeshes.AbstractMesh. All of them are supposed to  behave as AbstractArray with elements being SVector representing the mesh points in Cartesian coordinates. ","category":"page"},{"location":"","page":"Home","title":"Home","text":"In addition to the interface of AbstractMeshes.AbstractMesh, four useful methods are defined: locate, volume, interp, and integrate. ","category":"page"},{"location":"","page":"Home","title":"Home","text":"locate(mesh, x) finds the mesh point nearest to x\nvolume(mesh, i) gives the volume represented by mesh point mesh[i]\ninterp(data, mesh, x) gives the interpolation of data on mesh at    point x\nintegrate(data, mesh) compute integration of data on mesh","category":"page"},{"location":"","page":"Home","title":"Home","text":"If it is known that some of the mesh points are guaranteed to have the same  data value, it's possible to define a MeshMap to reveal this fact and  create a ReducedBZMesh to save storage space.","category":"page"},{"location":"#Brillouin-zone","page":"Home","title":"Brillouin zone","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The information of Brillouin zone is stored in Cells.Cell.  Including lattice vector, reciprocal lattice vector and their inverse; volume of unit cell and reciprocal unit cell; G vectors for extended  Brillouin zone and symmetries.","category":"page"},{"location":"#Uniform-Meshes","page":"Home","title":"Uniform Meshes","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Uniform meshes are defined as uniformly distributed meshes on a  parallellogram area described by an origin and a set of lattice vectors. The simplest one is BaseMesh.UMesh, while BZMeshes.UniformBZMesh  containes additional information about the Brillouin zone stored in its cell field. ","category":"page"},{"location":"","page":"Home","title":"Home","text":"Uniform meshes are conventionally used in various ab initio calculations.  In this package various frequently used meshes, such as Gamma-centered and  Monkhorst-Pack meshes, could be generated via BZMeshes.UniformBZMesh with  different parameters. The default parameter of the constructor of  BZMeshes.UniformBZMesh generates Gamma-centered mesh, while two constructors for M-P mesh, Monkhorst_Pack and DFTK_Monkhorst_Pack, follow conventions from VASP and DFTK respectively.","category":"page"},{"location":"lib/BaseMesh/#BaseMesh","page":"BaseMesh","title":"BaseMesh","text":"","category":"section"},{"location":"lib/BaseMesh/","page":"BaseMesh","title":"BaseMesh","text":"This module provides basical meshes.","category":"page"},{"location":"lib/BaseMesh/","page":"BaseMesh","title":"BaseMesh","text":"Modules = [BrillouinZoneMeshes.BaseMesh]","category":"page"},{"location":"lib/BaseMesh/#BrillouinZoneMeshes.BaseMesh.AbstractUniformMesh","page":"BaseMesh","title":"BrillouinZoneMeshes.BaseMesh.AbstractUniformMesh","text":"abstract type AbstractUniformMesh{T,DIM} <: AbstractMesh{T,DIM}\n\nParent type of all uniform meshes. \n\nMesh points of a uniform mesh is assumed to be uniformly distributed  in an parrallelogram area. Uniform meshes support fractional coordinates.\n\nAll concrete implementations of this abstract type are assumed to have the following fields:\n\nRequired Fields:\n\norigin: the origin(bottom-left point) of the area\nshift: the fractional coordinate shift of the mesh. This is useful to reproduce M-P mesh commonly used in DFT.\n\nand have the following methods implemented:\n\nRequired Methods:\n\nlattice_vector: return lattice vector of the represented area\ninv_lattice_vector: return inverse of lattice vector\ncell_volume: return cell volume\n\n\n\n\n\n","category":"type"},{"location":"lib/BaseMesh/#BrillouinZoneMeshes.BaseMesh.UMesh","page":"BaseMesh","title":"BrillouinZoneMeshes.BaseMesh.UMesh","text":"struct UMesh{T,DIM} <: AbstractUniformMesh{T,DIM}\n\nSimplest uniform mesh with lattice/invlattice/cellvolume stored.\n\nFields:\n\nlattice: lattice vector\ninv_lattice: inverse lattice vector\ncell_volume: volume of the area represented\norigin: the origin(bottom-left point) of the area\nsize: size of the mesh\nshift: the fractional coordinate shift of the mesh. This is useful to reproduce M-P mesh commonly used in DFT.\n\n\n\n\n\n","category":"type"},{"location":"lib/BaseMesh/#BrillouinZoneMeshes.BaseMesh.UMesh-Union{Tuple{}, Tuple{DIM}, Tuple{T}} where {T, DIM}","page":"BaseMesh","title":"BrillouinZoneMeshes.BaseMesh.UMesh","text":"UMesh(;br::Cell{T,DIM}, origin, size, shift)\n\nConstruct a UMesh from a brillouin zone with given origin, size and shift.\n\nParameters:\n\nbr: brillouin zone containing information of the area represented\norigin: the origin(bottom-left point) of the area\nsize: size of the mesh\nshift: the fractional coordinate shift of the mesh. This is useful to reproduce M-P mesh commonly used in DFT.\n\n\n\n\n\n","category":"method"},{"location":"lib/BaseMesh/#BrillouinZoneMeshes.AbstractMeshes.integrate-Tuple{Any, AbstractUniformMesh}","page":"BaseMesh","title":"BrillouinZoneMeshes.AbstractMeshes.integrate","text":"function AbstractMeshes.integrate(data, mesh::AbstractUniformMesh)\n\nDefault integration for uniform meshes. Use zeroth-order integration,  i.e. average value times volume.\n\nParameters:\n\ndata: data\nmesh: mesh\n\n\n\n\n\n","category":"method"},{"location":"lib/BaseMesh/#BrillouinZoneMeshes.AbstractMeshes.locate-Union{Tuple{DIM}, Tuple{T}, Tuple{AbstractUniformMesh{T, DIM}, Any}} where {T, DIM}","page":"BaseMesh","title":"BrillouinZoneMeshes.AbstractMeshes.locate","text":"function AbstractMeshes.locate(mesh::AbstractUniformMesh{T,DIM}, x) where {T,DIM}\n\nlocate mesh point in mesh that is nearest to x. Useful for Monte-Carlo algorithm. Could also be used for zeroth order interpolation.\n\nParameters\n\nmesh: aimed mesh\nx: cartesian pos to locate\n\n\n\n\n\n","category":"method"},{"location":"lib/BaseMesh/#BrillouinZoneMeshes.AbstractMeshes.volume-Tuple{AbstractUniformMesh}","page":"BaseMesh","title":"BrillouinZoneMeshes.AbstractMeshes.volume","text":"function AbstractMeshes.volume(mesh::AbstractUniformMesh, i)\n\nvolume represented by mesh point i. When i is omitted return volume of the whole mesh.  For M-P mesh it's always volume(mesh)/length(mesh), but for others things are more complecated. Here we assume periodic boundary condition so for all case it's the same.\n\nParameters:\n\nmesh: mesh\ni: index of mesh point, if ommited return volume of whole mesh\n\n\n\n\n\n","category":"method"},{"location":"lib/MeshMaps/#MeshMaps","page":"MeshMaps","title":"MeshMaps","text":"","category":"section"},{"location":"lib/MeshMaps/","page":"MeshMaps","title":"MeshMaps","text":"This module defines MeshMap and ReducedBZMesh which provides  symmetry-reduced meshes.","category":"page"},{"location":"lib/MeshMaps/","page":"MeshMaps","title":"MeshMaps","text":"Modules = [BrillouinZoneMeshes.MeshMaps]","category":"page"},{"location":"lib/MeshMaps/#BrillouinZoneMeshes.MeshMaps.MeshMap","page":"MeshMaps","title":"BrillouinZoneMeshes.MeshMaps.MeshMap","text":"struct MeshMap\n\nMapping from full mesh to irreducible mesh. The reduction is mainly available via symmetry operations.\n\nParameters:\n\nmap: mapping from full mesh to irreducible mesh. When i is the index of a point in the full mesh, map[i] is the corresponding index in reduced mesh\nreduced_length: the length of reduced mesh\ninv_map: inverse of map. When i is the index of a point in the reduced mesh, inv_map[i] is a list of all points corresponding to this point in the full mesh\n\n\n\n\n\n","category":"type"},{"location":"lib/MeshMaps/#BrillouinZoneMeshes.MeshMaps.ReducedBZMesh","page":"MeshMaps","title":"BrillouinZoneMeshes.MeshMaps.ReducedBZMesh","text":"struct ReducedMesh{MT}\n\nMap-reduced mesh constructed from mesh::MT with symmetry reduction.\n\nParameters:\n\nmesh: bare mesh from which the reduced mesh constructed\nmeshmap: map from mesh to the reduced mesh\n\n\n\n\n\n","category":"type"}]
}
